05 c++项目如何工作
  本节以helloworld为例，介绍vs的使用和c++的一些基础知识。
	(1) #后面的都是预处理语句(preprocess statement),在编译执行就被处理。将#include后面头文件的内容全部复制粘贴进来。
	(2) main函数是项目入口，其返回类型只能是整型，用户不返回任何值时，默认返回0。
	(3) << 是一个重载运算符(overloaded operator)，把它理解为一个函数。
	(4) VS里的解决方案配置的release模式相比于debug模式进行了很多优化，运行速度也快很多。但使用debug模式更利于我们调代码。
	(5) 项目内的每一个.cpp文件会被编译成相应的.obj二进制文件，而.h的头文件不被编译，因为它们被一些相应的cpp文件包括了。
	(6) 每个cpp文件单独地被编译成obj文件，这些obj文件需要组合在一起形成一个可执行的exe文件，这就是链接器(linker)的作用。
	(7) c++中任何符号都需要一定意义上的声明，比如cout，其在iostream中被声明。
	(8) 声明(declaration) ※
		    在一个文件内需要调用另一个文件内定义的函数时，我们需要对函数事先声明(declaration)。声明部分没有函数体，其作用是告诉编译器我们使用的函数是存在的。
		事实上，编译器并不关心是否存在该函数，甚至就算不存在该函数，只要我们声明过都能正常编译。而当我们build project时会有Linker错误。找到函数定义并且导入
		声明的函数中的工作是链接器(Linker)的工作。


06 编译器是如何工作的
  代码从我们写的文本形式到可执行的exe文件形式的过程中需要经过两个过程，编译器的编译和链接器的链接。Compiler将这些文本文件分别编译成obj形式的二进制中间文件，
linker将这些obj文件整合到一起生成计算机可执行的exe文件。
	(1)编译器编译文本文件时做的几件事 ※
		a.预处理(preprocess)代码
		b.记号化(tokenizing)和解析(parsing)c++代码使之成为编译器可以理解的形式,这个步骤下所谓的抽象语法树(Abstract Syntax tree)被创建，其为我们代码的一种表
		  示形式。
		c.转换我们所有代码为或是常量数据或是指令。一旦抽象语法树被创建，编译器就可以开始生成cpu可以执行的机器语言了。我们也得到了其他各种数据，如一个储存有
		  常量和变量的地方。
	(2)cpp文件和翻译单元
		   项目中的每个cpp文件都被独立的编译成相应的obj文件，这些cpp文件也被称为翻译单元(traslation unit)。需要注意的是，cpp文件和翻译单元是有区别的。在一些
		项目中，存在一个cpp文件包含一些子cpp文件的情况，这时最外层最大的那个cpp文件为翻译单元，由翻译单元生成一个obj文件。obj文件内全是二进制数，实际上这些
		数字表达的是调用该cpp程序时cpu对应运行的机器码。
	(3)编译的第一阶段：预处理#
		   常用的预处理语句有#include,#define,#if,#ifdef,#pragma等。拿#include为例，其作用就是将被include的文件中的内容复制粘贴到被编译文件的相应位置；而define
		可在编写代码中将一些关键字等替换成更简单的符号，预处理后会自动进行替换；if可以根据我们给定的条件预处理的过程中包含或排除相应代码段。
	(4)在 项目名-属性-c/c++-预处理器 设置中，将预处理到文件设置为是后，每次编译可以从项目中的debug文件夹下得到预处理后的i文件,此选项将取消编译，不再生成obj文件。
	(5)在 项目名-属性-c/c++-输出文件 设置中，将汇编文件输出选项设置为(FA)后，每次编译可以从项目中的debug文件夹下得到编译后的汇编(ASM)文件。
	(6)如果想优化代码，在 项目名-属性-c/c++-优化 设置中，将优化选项设置为最大优化(优化速度O2)后，直接编译会报错，因为O2和RTC不兼容。在 项目名-属性-c/c++-代码生
	成设置中，将基本运行时检查选项从两者更改为默认值即可解决该问题。该优化模式下，一些并不产生实际用处的语句会被编译器删除。


07 链接器是如何工作的
  编译器将每个翻译单元编译为相应的obj文件后，有linker将它们组合在一起生成一个可执行文件。链接的主要焦点在于找到相应的符号和函数，并把相应内容连接起来。即使没有
其他cpp文件也要对main文件进行链接，因为计算机执行文件时需要知道入口在哪里。
	(1) 程序报错时，如果错误编码由C开头，那么错误是在编译阶段产生的，其大概率为语法错误(syntax error)；如果由LNK打头，其在链接阶段产生，为链接器错误。
	(2) 入口点
		  没有main函数的项目是无法运行起来的，因为每个exe文件运行时都要有一个入口点(entry point)，这是默认main函数提供的。但在 项目名-属性-链接器-高级 设置中，
		有一个入口点选项，我们可以指定自己的入口点，因此入口点不一定是main函数，只要有即可。
	(3) 未解决的外部符号(unresolved external symbol) ※
		  当linker找不到它需要的东西时(如声明但未定义的函数)，会发生此错误。！！需要注意的是，如果我们声明了没有定义过的函数但没有调用过它，那么当我们build项目
		时，linker不会报错，因为linker没有用到链接它；但是如果我们在一个其他函数中调用了这个函数，即使这个其他函数没有被调用过，build项目时依然会有链接器错误发
		生，因为即使我们在这个文件中没调用这个函数，我们也可能在其他文件中调用这个函数了，链接器确实需要去链接它。除非我们可以告诉编译器这个调用了声明但未定义的
		函数的其他函数只在当前文件中被调用。事实上，有一种做法可以做到这一点，就是在定义这个其他函数前在其返回类型前加一个关键字static。static指代的是文件内的作
		用域。
	(4) 声明其他文件中定义的函数时，不仅名称要对应，返回类型也不能出错，其参数列表也要一一对应。
	(5) 重复的符号(duplicated symbols) ※
		  重复的符号是另一种常见的linker报错情况。当我们在不同文件中定义的两个函数有同样的返回类型，函数名和函数签名时，当我们build project，会有linking error。
		因为这种情况下，链接器不知道要去链接哪一个函数。不要认为你不会犯这种低级错误，以下是你可能会无意犯错的几种情况:
			a.当我们在头文件中定义某个函数，恰好两个cpp文件中都要调用它，我们在两个文件中都#include了这个头文件，由于#include预处理的本质就是将其包括的头文件的
			  内容复制粘贴到文件中，那么相当于在两个文件中都有了这个函数的定义，因此会产生这个错误。我们有几种方式去解决它：
				①.在头文件定义函数时将函数定义为静态(static)的。这意味着在链接这个函数时，该函数只能是内部函数。即在不同文件中#include这个函数时，这个函数都是
				以静态的形式定义的，也就是说函数只服务于当前文件，不同文件中调用的互相独立，对其他obj文件都不可见，因此不会引起linker的错误。
				②.还有一种方法是在头文件定义函数的返回类型前加上inline。inline的作用就是获取我们定义函数的函数体内的内容，并将其他文件中调用此函数的语句替换为
				函数体里的内容。
				③.还有一种解决方式就是将头文件中函数的定义移到一个翻译单元中去，而头文件中只保留对函数的声明（较为推荐）。