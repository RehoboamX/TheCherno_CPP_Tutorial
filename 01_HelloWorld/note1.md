# Lesson5 c++项目如何工作
#### 本节以helloworld为例，介绍vs的使用和c++的一些基础知识。
(1) #后面的都是**预处理语句(preprocess statement)**,在编译执行就被处理。如#**include**就是将其后面头文件的内容全部复制粘贴进来。  
(2) main函数是项目入口，其返回类型只能是整型，用户不返回任何值时，默认返回0。
(3) **<<** 是一个**重载运算符(overloaded operator)**，把它理解为一个函数，类似.print()。
(4) VS里的解决方案配置的release模式相比于debug模式进行了很多优化，运行速度也快很多。但使用debug模式更利于我们调代码。  
(5) 项目内的每一个.**cpp**文件会被编译成相应的.**obj**二进制文件，而.**h**的头文件不被编译，因为它们被一些相应的**cpp**文件#**include**了。  
(6) 每个**cpp**文件单独地被编译成**obj**文件，这些**obj**文件需要组合在一起形成一个可执行的**exe**文件，这就是**链接器**(linker)的作用。  
(7) c++中任何符号都需要一定意义上的**声明**，比如cout，其在iostream中被声明。  
(8) **声明**(**declaration**) ※  
- 在一个文件内需要调用另一个文件内定义的函数时，我们需要对函数事先**声明**(declaration)。声明部分没有函数体，其作用是告诉编译器我们使用的函数是存在的。事实上，编译器并不关心是否存在该函数，甚至就算不存在该函数，只要我们声明过都能正常编译。而当我们build project时会有**Linker错误**。找到函数定义并且导入被声明的函数中的工作是**链接器**(Linker)的工作。
  

# Lesson6 编译器是如何工作的
#### 代码从我们写的文本形式到可执行的exe文件形式的过程中需要经过两个过程，编译器的编译和链接器的链接。Compiler将这些文本文件分别编译成obj形式的二进制中间文件，linker将这些obj文件整合到一起生成计算机可执行的exe文件。  
(1) **编译器编译文本文件时做的几件事** ※  
- **预处理**(**preprocess**)代码  
- **记号化**(**tokenizing**)和**解析**(**parsing**)c++代码使之成为编译器可以理解的形式,这个步骤下所谓的**抽象语法树**(**Abstract Syntax tree**)被创建，其为我们代码的一种表示形式。  
- 转换我们所有代码为或是**常量数据**或是**指令**。一旦**抽象语法树**被创建，编译器就可以开始生成cpu可以执行的机器语言了。我们也得到了其他各种数据，如一个储存有常量和变量的地方。  

(2) cpp文件和翻译单元  
- 项目中的每个**cpp**文件都被独立的编译成相应的**obj**文件，这些**cpp**文件也被称为**翻译单元**(**traslation unit**)。需要注意的是，cpp文件和翻译单元是有区别的。在一些项目中，存在一个cpp文件包含一些子cpp文件的情况，这时最外层最大的那个cpp文件为**翻译单元**，由翻译单元生成一个obj文件。obj文件内全是二进制数，实际上这些数字表达的是调用该cpp程序时cpu对应运行的机器码。  

(3) 编译的第一阶段：**预处理**#  
- 常用的预处理语句有#**nclude**,#**define**,#**if**,#**ifdef**,#**pragma**等。拿#**include**为例，其作用就是将被**include**的文件中的内容复制粘贴到被编译文件的相应位置；而**define**可在编写代码中将一些关键字等替换成更简单的符号，预处理后会自动进行替换；**if**可以根据我们给定的条件预处理的过程中包含或排除相应代码段。

(4) 在 ***项目名-属性-c/c++-预处理器*** 设置中，将***预处理到文件***设置为是后，每次编译可以从项目中的debug文件夹下得到预处理后的**i文件**,此选项将取消编译，不再生成obj文件。  
(5) 在 ***项目名-属性-c/c++-输出文件*** 设置中，将***汇编文件输出***选项设置为(FA)后，每次编译可以从项目中的debug文件夹下得到编译后的**汇编**(**ASM**)文件。  
(6) 如果想优化代码，在 ***项目名-属性-c/c++-优化*** 设置中，将***优化选项***设置为最大优化(优化速度O2)后，直接编译会报错，因为O2和RTC不兼容。在 ***项目名-属性-c/c++-代码生成***设置中，将***基本运行时检查***选项从两者更改为默认值即可解决该问题。该优化模式下，一些并不产生实际用处的语句会被编译器删除。


# Lesson7 链接器是如何工作的
#### 编译器将每个翻译单元编译为相应的obj文件后，有linker将它们组合在一起生成一个可执行文件。链接的主要焦点在于找到相应的符号和函数，并把相应内容连接起来。即使没有其他cpp文件也要对main文件进行链接，因为计算机执行文件时需要知道入口在哪里。
(1) 程序报错时，如果错误编码由**C**开头，那么错误是在编译阶段产生的，其大概率为**语法错误**(**syntax error**)；如果由**LNK**打头，其在链接阶段产生，为**链接器错误**。  
(2) **入口点**  
- 没有main函数的项目是无法运行起来的，因为每个exe文件运行时都要有一个**入口点**(**entry point**)，这是默认**main函数**提供的。但在 ***项目名-属性-链接器-高级*** 设置中，有一个***入口点***选项，我们可以指定自己的入口点，因此入口点不一定是main函数，只要有即可。

(3) **未解决的外部符号**(**unresolved external symbol**) ※
- 当linker找不到它需要的东西时(如声明但未定义的函数)，会发生此错误。！！需要注意的是，如果我们声明了没有定义过的函数但没有调用过它，那么当我们build项目时，linker不会报错，因为linker没有用到链接它；但是如果我们在一个其他函数中调用了这个函数，即使这个其他函数没有被调用过，build项目时依然会有链接器错误发生，因为即使我们在这个文件中没调用这个函数，我们也可能在其他文件中调用这个函数了，链接器确实需要去链接它。除非我们可以告诉编译器这个调用了声明但未定义的函数的其他函数只在当前文件中被调用。事实上，有一种做法可以做到这一点，就是在定义这个其他函数前在其返回类型前加一个**关键字static**。**static**指代的是**文件内的作用域**。

(4) 声明其他文件中定义的函数时，不仅名称要对应，返回类型也不能出错，其参数列表也要一一对应。  
(5) **重复的符号**(**duplicated symbols**) ※  
　　重复的符号是另一种常见的linker报错情况。当我们在不同文件中定义的两个函数有同样的返回类型，函数名和函数签名时，当我们build project，会有linking error。因为这种情况下，链接器不知道要去链接哪一个函数。不要认为你不会犯这种低级错误，以下是你可能会无意犯错的情况:  

　　当我们在头文件中定义某个函数，恰好两个cpp文件中都要调用它，我们在两个文件中都#include了这个头文件，由于#include预处理的本质就是将其包括的头文件的内容复制粘贴到文件中，那么相当于在两个文件中都有了这个函数的定义，因此会产生这个错误。我们有几种方式去解决它：  
- 1.在头文件定义函数时将函数定义为**静态**(**static**)的。这意味着在链接这个函数时，该函数只能是**内部函数**。即在不同文件中#include这个函数时，这个函数都是以静态的形式定义的，也就是说函数只服务于当前文件，不同文件中调用的互相独立，对其他obj文件都不可见，因此不会引起linker的错误。
- 2.还有一种方法是在头文件定义函数的返回类型前加上**inline**。**inline**的作用就是获取我们定义函数的函数体内的内容，并将其他文件中调用此函数的语句替换为函数体里的内容。
- 3.※还有一种解决方式就是将头文件中函数的定义移到**一个翻译单元**中去，而头文件中只保留对函数的**声明**（较为推荐）。